# üõ†Ô∏è MonacoEngine ‚Äî Motor Gr√°fico (Proyecto Parcial)

## üìã Resumen  
MonacoEngine es un motor gr√°fico 3D educativo desarrollado para la materia de Gr√°ficas Computacionales. Tiene por objetivo servir como base para exploraci√≥n de pipelines gr√°ficos, renderizado, manejo de recursos, escenas y shaders.

## üìå √çndice  
- Resumen  
- Objetivos del proyecto  
- Arquitectura general  
  - Componentes principales  
  - Relaciones operativas  
- Pipeline gr√°fico implementado  
- Flujo de inicializaci√≥n  
- Flujo de render (por frame)  
- Clases / API clave  
- Requisitos / C√≥mo ejecutar  
- Limitaciones y trabajo futuro  
- Cr√©ditos / Referencias  

---

## üéØ Objetivos del proyecto  
| Objetivo | Descripci√≥n |
|---|---|
| Arquitectura modular | Separar responsabilidades (gesti√≥n de ventana, dispositivo gr√°fico, recursos, escena, presentaci√≥n) |
| Comprensi√≥n de pipeline | Implementar paso a paso la creaci√≥n de recursos, configuraci√≥n del pipeline y ciclo de render |
| Render m√≠nimo funcional | Mostrar un objeto (por ejemplo, un cubo texturizado) actualiz√°ndose por frame |
| Extensibilidad | Proveer funciones `update()` / `render()` o puntos de extensi√≥n para agregar m√°s caracter√≠sticas |
| Gesti√≥n de recursos | Manejo de buffers, texturas, shaders y limpieza adecuada |

---

## üèó Arquitectura general

> Dise√±o modular que favorece la mantenibilidad, escalabilidad y extensi√≥n futura.

### Componentes principales

| Componente | Responsabilidad | API / recursos clave |
|---|---|---|
| **Window / Ventana** | Crear y manejar la ventana de la aplicaci√≥n (resoluci√≥n, eventos) | `init(...)`, `destroy()`, manejo de callbacks de ventana |
| **GraphicsDevice / Contexto** | Inicializar el medio gr√°fico (OpenGL, Vulkan, etc.), gestionar comandos | creaci√≥n de buffers, estados gr√°Ô¨Åcos, env√≠o de draw calls |
| **Swap Chain / Presentaci√≥n** | Intercambiar buffers frente / posterior para mostrar el frame | `present()`, configurar doble/triple b√∫fer |
| **Shader Manager** | Cargar, compilar y gestionar programas de shaders (vertex, fragment, etc.) | `loadShader()`, `useShader()`, recompilaci√≥n |
| **Mesh / Geometry** | Representar geometr√≠a 3D con v√©rtices, √≠ndices, normales, UVs | `VertexBuffer`, `IndexBuffer`, `Draw()` |
| **Material / Textura** | Asociar propiedades visuales (texturas, colores, mapas normales) | binding de texturas, par√°metros uniformes |
| **Camera** | Coordenadas de vista y proyecci√≥n | matrices view / proj, actualizaci√≥n de posici√≥n |
| **Light / Sistema de iluminaci√≥n** | Definir fuentes de luz, par√°metros (color, posici√≥n, intensidad) | c√°lculo de iluminaci√≥n en shader |
| **Renderer / Pipeline** | Orquestar el flujo de renderizado usando los componentes anteriores | `render(scene)`, administraci√≥n de estados gr√°ficos |
| **Scene / Escena** | Mantener los objetos, luces y c√°mara de la escena | `addObject()`, `update()`, `getRenderableObjects()` |

### Relaciones operativas

El flujo t√≠pico entre componentes es:

1. `Window` inicializa la ventana del sistema.  
2. `GraphicsDevice` crea el contexto/gr√°ficos.  
3. `SwapChain` se conecta al `GraphicsDevice` y `Window` para la presentaci√≥n.  
4. `Renderer` consulta la `Scene` para obtener objetos visibles.  
5. Por cada objeto, el `Renderer` selecciona el `Mesh`, el `Material`, obtiene el `Shader` desde `Shader Manager`, y env√≠a draw calls al `GraphicsDevice`.  
6. Al final del frame, se llama a `SwapChain.present()` para mostrar el resultado en pantalla.

---

## üì∑ Pipeline gr√°fico implementado

Este es el pipeline gr√°fico b√°sico que MonacoEngine debe implementar:

1. **Inicializaci√≥n gr√°fica**  
   - Crear contexto / dispositivo gr√°fico  
   - Crear y compilar shaders  
   - Crear buffers (vertex, index, constantes)  
   - Configurar estado gr√°fico (viewport, rasterizador, depth test, blending)

2. **Transformaciones / Etapa de v√©rtice**  
   - Aplicar transformaciones: `model ‚Üí world ‚Üí view ‚Üí projection`  
   - Realizar frustum culling o backface culling si aplica  
   - Enviar posiciones, normales, UVs a la etapa de fragmento

3. **Rasterizaci√≥n / fragmentaci√≥n**  
   - Rasterizar primitivas (tri√°ngulos)  
   - Interpolar atributos (normales, UVs) por fragmento

4. **Shading / iluminaci√≥n**  
   - Ejecutar shader fragmento para calcular color: ambient + difusa + especular  
   - Muestreo de texturas, mapas normales u otros mapas

5. **Depth / Blending / Salida**  
   - Prueba de profundidad (z-buffer)  
   - Blending si hay transparencia  
   - Escritura al frame buffer

6. **Presentaci√≥n / Swap**  
   - Intercambiar los buffers para mostrar la imagen final

---

## üöÄ Flujo de inicializaci√≥n

1. `Window.init(...)` ‚Üí crea la ventana del sistema  
2. `GraphicsDevice.init()` ‚Üí inicializa el contexto gr√°fico  
3. `ShaderManager.loadShaders(...)` ‚Üí compila los shaders iniciales  
4. `Mesh` / `Material` se crean / cargan, buffers asignados  
5. Estado gr√°fico configurado (viewport, pruebas de profundidad, etc.)  
6. Bucle principal: `while(running) { update(); render(); }`

---

## ‚è± Flujo de render (por frame)

1. Limpiar buffers (color, profundidad)  
2. Preparar la lista de objetos visibles / frustum culling  
3. Para cada objeto:  
   - Actualizar constantes (matrices, par√°metros del material)  
   - Bind de shader / texturas / recursos  
   - Establecer buffers de v√©rtices / √≠ndices  
   - Llamada de dibujo (draw)  
4. Ejecutar efectos post-proceso si existen  
5. Presentar / swap buffers  

---

## üìö Clases / API clave (ejemplos)

Aqu√≠ algunos m√©todos importantes que podr√≠an existir:

- `Window::init(hInst, width, height)`  
- `GraphicsDevice::createBuffer(...)`, `createTexture(...)`, `setRenderState(...)`  
- `ShaderManager::loadShader(name, vsPath, fsPath)`  
- `Mesh::setVertices(...)`, `Mesh::draw()`  
- `Material::bind()`  
- `Renderer::render(Scene &scene)`  
- `Camera::getViewProjMatrix()`  
- `Light::parameters()`  

---

## üíª Requisitos / C√≥mo ejecutar

**Requisitos**  
- Sistema operativo: Windows / Linux / macOS (seg√∫n lo que soporte tu motor)  
- Librer√≠as gr√°ficas: OpenGL (versi√≥n m√≠nima), Vulkan, DirectX, etc.  
- Un compilador compatible con C++17 (u otra versi√≥n que uses)  
- Dependencias externas (librer√≠as math, SDL/GLFW, stb_image, etc.)

**Pasos para ejecutar**  
1. Clona este repositorio  
   ```bash
   git clone https://github.com/tu-usuario/MonacoEngine.git
